<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knowledge Graph Viewer</title>
    <!-- Import vis-network library -->
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden; /* Prevent body scrollbars */
            background-color: #f0f2f5;
        }
        h1, h2, h3 {
             color: #2c3e50;
             margin-top: 0;
        }
        .container {
            display: flex;
            height: 100vh; /* Full viewport height */
            width: 100%;
        }
        #graph-container {
            flex-grow: 1; /* Takes up remaining space */
            height: 100%;
            border-right: 2px solid #d1d9e6;
            background-color: #ffffff;
        }
        #sidebar {
            width: 350px; /* Fixed width for sidebar */
            flex-shrink: 0; /* Prevent sidebar from shrinking */
            height: 100%;
            overflow-y: auto; /* Allow scrolling within sidebar */
            background-color: #f8f9fa;
            padding: 20px;
            box-sizing: border-box; /* Include padding in width */
            display: flex;
            flex-direction: column;
        }
        #details-panel {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            flex-shrink: 0; /* Prevent shrinking */
            max-height: 40%; /* Limit details panel height */
            overflow-y: auto; /* Scroll if content overflows */
        }
        #details-panel h3 {
             margin-bottom: 10px;
             padding-bottom: 5px;
             border-bottom: 1px solid #ced4da;
        }
         #details-panel p {
             margin: 5px 0;
             word-wrap: break-word; /* Wrap long text */
         }
         #details-panel code {
             background-color: #d1d9e6;
             padding: 2px 4px;
             border-radius: 3px;
             font-size: 0.9em;
         }

        #chat-container {
            flex-grow: 1; /* Takes remaining space in sidebar */
            display: flex;
            flex-direction: column;
            border: 1px solid #d1d9e6;
            border-radius: 8px;
            background-color: #fff;
            overflow: hidden; /* Clip content */
        }
        #chat-log {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
        }
        .chat-message {
             margin-bottom: 10px;
             padding: 8px 12px;
             border-radius: 15px;
             max-width: 80%;
             word-wrap: break-word;
         }
         .user-message {
             background-color: #3498db;
             color: white;
             margin-left: auto; /* Align right */
             border-bottom-right-radius: 5px;
         }
         .bot-message {
             background-color: #ecf0f1;
             color: #333;
             margin-right: auto; /* Align left */
              border-bottom-left-radius: 5px;
         }
        #chat-input-area {
            display: flex;
            padding: 10px;
            border-top: 1px solid #d1d9e6;
            background-color: #f8f9fa;
        }
        #chat-input {
            flex-grow: 1;
            padding: 8px 10px;
            border: 1px solid #ced4da;
            border-radius: 15px;
            margin-right: 8px;
            font-size: 0.95rem;
        }
        #send-btn {
            padding: 8px 15px;
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
        }
         #send-btn:hover {
              background-color: #27ae60;
         }
         nav {
             position: absolute; /* Position nav on top */
             top: 0;
             left: 0;
             width: 100%;
             background: rgba(52, 73, 94, 0.85); /* Semi-transparent dark */
             padding: 8px 0;
             text-align: center;
             z-index: 10; /* Ensure nav is above graph */
         }
         nav a {
             color: white;
             text-decoration: none;
             margin: 0 15px;
             font-weight: bold;
             font-size: 0.9em;
         }
         nav a:hover {
             text-decoration: underline;
         }

    </style>
</head>
<body>
    <nav>
        <a href="/">Consultation Analyzer</a>
        <a href="/kg-input">KG Input</a>
        <a href="/kg-view">KG Viewer</a>
    </nav>
    <div class="container">
        <div id="graph-container"></div>
        <div id="sidebar">
            <h2>Graph Details & Chat</h2>
            <div id="details-panel">
                <h3>Selection Details</h3>
                <p>Click on a node or edge to see details here.</p>
            </div>
            <div id="chat-container">
                <div id="chat-log">
                     <div class="bot-message">Hello! Ask me questions about the graph or selected items. (Editing not yet implemented).</div>
                </div>
                <div id="chat-input-area">
                    <input type="text" id="chat-input" placeholder="Ask about the graph...">
                    <button id="send-btn">Send</button>
                </div>
            </div>
        </div>
    </div>

    <script type="text/javascript">
        const graphContainer = document.getElementById('graph-container');
        const detailsPanel = document.getElementById('details-panel');
        const chatLog = document.getElementById('chat-log');
        const chatInput = document.getElementById('chat-input');
        const sendBtn = document.getElementById('send-btn');

        let network = null;
        let graphData = { nodes: [], edges: [] }; // Store fetched data
        let selectedNodeId = null;
        let selectedEdgeId = null;

        // --- Entity Type Styling ---
        const entityColors = {
            TENANT_ISSUE: '#e74c3c', // Red
            STATUTE: '#2980b9',      // Blue
            REGULATION: '#3498db',   // Lighter Blue
            CASE: '#f1c40f',         // Yellow
            REMEDY: '#2ecc71',       // Green
            EVIDENCE_TYPE: '#9b59b6',// Purple
            LEGAL_PROCEDURE: '#e67e22',// Orange
            LEGAL_CONCEPT: '#1abc9c', // Turquoise
            JURISDICTION: '#7f8c8d',  // Grey
            DEFAULT: '#bdc3c7',      // Light Grey
            // Concept group styling
            CONCEPT_GROUP: '#34495e'  // Dark blue for concept groups
        };

         const entityShapes = {
            TENANT_ISSUE: 'star',
            STATUTE: 'box',
            REGULATION: 'box',
            CASE: 'ellipse',
            REMEDY: 'diamond',
            EVIDENCE_TYPE: 'triangle',
            LEGAL_PROCEDURE: 'hexagon',
            LEGAL_CONCEPT: 'dot',
            JURISDICTION: 'square',
            DEFAULT: 'ellipse',
            // Concept group shape
            CONCEPT_GROUP: 'database'  // Database shape for concept groups
         };

        // --- Vis.js Network Initialization ---
        async function initializeGraph() {
            try {
                console.log("Fetching graph data...");
                
                // Fetch both graph data and concept groups
                const [graphResponse, conceptGroupsResponse] = await Promise.all([
                    fetch('/api/kg/graph-data'),
                    fetch('/api/kg/concept-groups')
                ]);
                
                if (!graphResponse.ok) {
                    throw new Error(`Graph data HTTP error! Status: ${graphResponse.status}`);
                }
                if (!conceptGroupsResponse.ok) {
                    console.warn(`Concept groups HTTP error! Status: ${conceptGroupsResponse.status}`);
                }
                
                const rawData = await graphResponse.json();
                const conceptGroupsData = conceptGroupsResponse.ok ? await conceptGroupsResponse.json() : { concept_groups: [] };
                
                console.log(`Received ${rawData.nodes?.length} nodes, ${rawData.links?.length} links, ${conceptGroupsData.concept_groups?.length} concept groups.`);

                // Process entity nodes for vis-network
                const entityNodes = rawData.nodes.map(node => ({
                    id: node.id, // ID used by vis
                    label: node.name || node.id, // Display name or ID
                    title: `Type: ${node.type}<br>ID: ${node.id}`, // Tooltip
                    shape: entityShapes[node.type] || entityShapes.DEFAULT,
                    color: entityColors[node.type] || entityColors.DEFAULT,
                    size: 20, // Standard size for entities
                    // Store all original data for details panel
                    originalData: node
                }));

                // Process concept group nodes
                const conceptGroupNodes = conceptGroupsData.concept_groups.map(group => ({
                    id: `group_${group.id}`, // Prefix to avoid conflicts
                    label: group.name,
                    title: `Concept Group: ${group.name}<br>Type: ${group.group_type}<br>Similarity: ${(group.similarity_score * 100).toFixed(1)}%<br>Entities: ${group.entity_count}`,
                    shape: entityShapes.CONCEPT_GROUP,
                    color: entityColors.CONCEPT_GROUP,
                    size: 30, // Larger size for concept groups
                    borderWidth: 3, // Thicker border for emphasis
                    font: { size: 14, bold: true }, // Larger, bold text
                    // Store concept group data
                    originalData: { ...group, isConceptGroup: true }
                }));

                // Combine all nodes
                const nodes = [...entityNodes, ...conceptGroupNodes];

                // Process entity relationships
                const entityEdges = rawData.links.map((link, index) => ({
                    id: `edge_${index}`, // Create a unique edge ID
                    from: link.source, // Use source ID
                    to: link.target,   // Use target ID
                    label: link.label || '', // Display relationship type
                    title: `Type: ${link.label}<br>Conditions: ${link.conditions || 'N/A'}`, // Tooltip
                    arrows: 'to',
                    font: { align: 'top' },
                    color: '#848484',
                    width: 1,
                    originalData: link
                }));

                // Create edges from entities to their concept groups
                const conceptGroupEdges = [];
                conceptGroupsData.concept_groups.forEach(group => {
                    group.entities.forEach(entity => {
                        conceptGroupEdges.push({
                            id: `group_edge_${group.id}_${entity.id}`,
                            from: entity.id,
                            to: `group_${group.id}`,
                            label: 'BELONGS_TO',
                            title: `Entity belongs to concept group: ${group.name}`,
                            arrows: 'to',
                            font: { align: 'top', size: 10 },
                            color: '#e74c3c', // Red color for group membership
                            width: 2,
                            dashes: true, // Dashed line to distinguish from regular relationships
                            originalData: { 
                                type: 'CONCEPT_GROUP_MEMBERSHIP',
                                group: group,
                                entity: entity
                            }
                        });
                    });
                });

                // Combine all edges
                const edges = [...entityEdges, ...conceptGroupEdges];

                graphData = { nodes, edges }; // Store processed data

                const options = {
                    nodes: {
                        font: { size: 12, color: '#333' },
                        borderWidth: 1,
                         shapeProperties: {
                             useBorderWithImage: true
                         }
                    },
                    edges: {
                        width: 1,
                        color: '#848484',
                        smooth: {
                            type: 'continuous' // Makes edges curvier
                        },
                        font: {
                             size: 10,
                             color: '#555',
                             strokeWidth: 0 // No background for edge label
                         }
                    },
                    physics: {
                        enabled: true,
                        solver: 'forceAtlas2Based', // Good general-purpose layout
                         forceAtlas2Based: {
                             gravitationalConstant: -50,
                             centralGravity: 0.01,
                             springLength: 100,
                             springConstant: 0.08,
                             avoidOverlap: 0.5 // Increase to reduce overlap
                         },
                         stabilization: { iterations: 150 } // More iterations for stability
                    },
                    interaction: {
                         hover: true, // Show tooltips on hover
                         tooltipDelay: 200
                     },
                     layout: {
                         // randomSeed: 2 // Uncomment for reproducible layout (useful for debugging)
                     }
                };

                network = new vis.Network(graphContainer, graphData, options);

                 // --- Event Listeners ---
                 network.on("click", function (params) {
                    handleSelection(params);
                 });

                 network.on("stabilizationIterationsDone", function () {
                     console.log("Layout stabilization complete.");
                     network.stopSimulation(); // Optional: stop physics after stabilization
                     // network.fit(); // Fit graph to view
                 });

                console.log("Graph initialized.");

            } catch (error) {
                console.error("Error initializing graph:", error);
                graphContainer.innerHTML = `<p style="color:red; padding: 20px;">Failed to load graph data: ${error.message}</p>`;
            }
        }

        // --- Selection Handling ---
        function handleSelection(params) {
             selectedNodeId = null; // Reset selections
             selectedEdgeId = null;

             if (params.nodes.length > 0) {
                 selectedNodeId = params.nodes[0];
                 const node = graphData.nodes.find(n => n.id === selectedNodeId);
                 displayNodeDetails(node);
             } else if (params.edges.length > 0) {
                  selectedEdgeId = params.edges[0]; // Use the generated edge ID
                  const edge = graphData.edges.find(e => e.id === selectedEdgeId);
                  displayEdgeDetails(edge);
             } else {
                 displayDefaultDetails(); // Clicked on empty space
             }
        }

        function displayNodeDetails(node) {
            if (!node || !node.originalData) {
                displayDefaultDetails();
                return;
            }
            const data = node.originalData;
            
            // Check if this is a concept group
            if (data.isConceptGroup) {
                let detailsHtml = `<h3>Concept Group: ${escapeHtml(data.name)}</h3>`;
                detailsHtml += `<p><strong>Group Type:</strong> ${escapeHtml(data.group_type)}</p>`;
                detailsHtml += `<p><strong>Similarity Score:</strong> ${(data.similarity_score * 100).toFixed(1)}%</p>`;
                detailsHtml += `<p><strong>Entity Count:</strong> ${data.entity_count}</p>`;
                if (data.description) {
                    detailsHtml += `<p><strong>Description:</strong> ${escapeHtml(data.description)}</p>`;
                }
                detailsHtml += `<p><strong>Entities in this group:</strong></p><ul>`;
                data.entities.forEach(entity => {
                    detailsHtml += `<li><strong>${escapeHtml(entity.name)}</strong> (${escapeHtml(entity.type)})`;
                    if (entity.description) {
                        detailsHtml += `: ${escapeHtml(entity.description)}`;
                    }
                    detailsHtml += `</li>`;
                });
                detailsHtml += `</ul>`;
                detailsPanel.innerHTML = detailsHtml;
                return;
            }
            
            // Regular entity display
            let detailsHtml = `<h3>Entity Details: ${escapeHtml(data.label || data.id)}</h3>`;
            detailsHtml += `<p><strong>ID:</strong> <code>${escapeHtml(data.id)}</code></p>`;
            detailsHtml += `<p><strong>Type:</strong> ${escapeHtml(data.type)}</p>`;
            if (data.description) {
                detailsHtml += `<p><strong>Description:</strong> ${escapeHtml(data.description)}</p>`;
            }
            if (data.jurisdiction_id) {
                 detailsHtml += `<p><strong>Jurisdiction:</strong> <code>${escapeHtml(data.jurisdiction_id)}</code></p>`;
            }
             if (data.source_reference) {
                 const sourceText = data.source_type === 'URL'
                     ? `<a href="${escapeHtml(data.source_reference)}" target="_blank">${escapeHtml(data.source_reference)}</a>`
                     : escapeHtml(data.source_reference);
                 detailsHtml += `<p><strong>Source (${escapeHtml(data.source_type || 'N/A')}):</strong> ${sourceText}</p>`;
            }
             if (data.attributes && Object.keys(data.attributes).length > 0) {
                 detailsHtml += `<p><strong>Attributes:</strong></p><ul>`;
                 for (const [key, value] of Object.entries(data.attributes)) {
                     detailsHtml += `<li><code>${escapeHtml(key)}</code>: ${escapeHtml(JSON.stringify(value))}</li>`;
                 }
                 detailsHtml += `</ul>`;
            }
            detailsPanel.innerHTML = detailsHtml;
        }

         function displayEdgeDetails(edge) {
             if (!edge || !edge.originalData) {
                 displayDefaultDetails();
                 return;
             }
              const data = edge.originalData;
              
              // Check if this is a concept group membership edge
              if (data.type === 'CONCEPT_GROUP_MEMBERSHIP') {
                  let detailsHtml = `<h3>Concept Group Membership</h3>`;
                  detailsHtml += `<p><strong>Entity:</strong> ${escapeHtml(data.entity.name)} (${escapeHtml(data.entity.type)})</p>`;
                  detailsHtml += `<p><strong>Concept Group:</strong> ${escapeHtml(data.group.name)}</p>`;
                  detailsHtml += `<p><strong>Group Type:</strong> ${escapeHtml(data.group.group_type)}</p>`;
                  detailsHtml += `<p><strong>Group Similarity:</strong> ${(data.group.similarity_score * 100).toFixed(1)}%</p>`;
                  if (data.entity.description) {
                      detailsHtml += `<p><strong>Entity Description:</strong> ${escapeHtml(data.entity.description)}</p>`;
                  }
                  if (data.group.description) {
                      detailsHtml += `<p><strong>Group Description:</strong> ${escapeHtml(data.group.description)}</p>`;
                  }
                  detailsPanel.innerHTML = detailsHtml;
                  return;
              }
              
              // Regular relationship display
              let detailsHtml = `<h3>Relationship Details</h3>`;
              detailsHtml += `<p><strong>From:</strong> <code>${escapeHtml(data.source)}</code></p>`;
              detailsHtml += `<p><strong>To:</strong> <code>${escapeHtml(data.target)}</code></p>`;
              detailsHtml += `<p><strong>Type:</strong> ${escapeHtml(data.label)}</p>`;
               if (data.conditions) {
                 detailsHtml += `<p><strong>Conditions:</strong> ${escapeHtml(data.conditions)}</p>`;
              }
               if (data.attributes && Object.keys(data.attributes).length > 0) {
                 detailsHtml += `<p><strong>Attributes:</strong></p><ul>`;
                 for (const [key, value] of Object.entries(data.attributes)) {
                     detailsHtml += `<li><code>${escapeHtml(key)}</code>: ${escapeHtml(JSON.stringify(value))}</li>`;
                 }
                 detailsHtml += `</ul>`;
              }
             detailsPanel.innerHTML = detailsHtml;
         }

        function displayDefaultDetails() {
            detailsPanel.innerHTML = '<h3>Selection Details</h3><p>Click on a node or edge to see details here.</p>';
        }


        // --- Chat Functionality (Placeholder) ---
        sendBtn.addEventListener('click', handleChatSend);
        chatInput.addEventListener('keypress', function (e) {
             if (e.key === 'Enter') {
                 handleChatSend();
             }
        });

        async function handleChatSend() {
            const message = chatInput.value.trim();
            if (!message) return;

            appendChatMessage(message, 'user');
            chatInput.value = ''; // Clear input

            appendChatMessage('Thinking...', 'bot', true); // Indicate bot is processing

            try {
                // --- Make the actual API call --- 
                console.log(`Sending message: ${message}, Context ID: ${selectedNodeId || selectedEdgeId}`);
                const apiResponse = await fetch('/api/kg/chat', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    // Send message and context (use node ID preferentially if both selected somehow)
                    body: JSON.stringify({ 
                        message: message, 
                        context_id: selectedNodeId || null // Send selected node ID, or null
                        // Note: We are not sending edge IDs to the context for now, as retrieving edge context is complex.
                    })
                });
                
                const result = await apiResponse.json(); // Try parsing JSON always

                if (!apiResponse.ok) { 
                     const errorDetail = result.detail || `Chat API Error: ${apiResponse.status}`;
                     throw new Error(errorDetail);
                }
                
                const botResponse = result.response || "Sorry, I received an empty response.";

                // Remove loading indicator before adding actual response
                 removeLoadingMessage();
                appendChatMessage(botResponse, 'bot');

            } catch (error) {
                 console.error("Chat API error:", error);
                 removeLoadingMessage(); // Remove loading indicator on error too
                 appendChatMessage(`Error: ${error.message}`, 'bot', false, true); // Indicate error
            }
        }

        function appendChatMessage(text, sender, isLoading = false, isError = false) {
             const messageDiv = document.createElement('div');
             messageDiv.classList.add('chat-message');
             messageDiv.classList.add(sender === 'user' ? 'user-message' : 'bot-message');
             if (isLoading) messageDiv.classList.add('loading-message'); // Add class for loading
             if (isError) messageDiv.style.backgroundColor = '#fdedec'; // Error style

             messageDiv.textContent = text;
             chatLog.appendChild(messageDiv);
             chatLog.scrollTop = chatLog.scrollHeight; // Scroll to bottom
        }

         function removeLoadingMessage() {
             const loadingMsg = chatLog.querySelector('.loading-message');
             if (loadingMsg) {
                 loadingMsg.remove();
             }
         }

        // --- Utility: HTML Escaping ---
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return unsafe;
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', initializeGraph);

    </script>
</body>
</html>
